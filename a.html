<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        #waveCanvas {
            display: block;
        }
    </style>
</head>
<body>

    <canvas id="waveCanvas"></canvas>

    <script>
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');
        let width = window.innerWidth;
        let height = window.innerHeight;

        canvas.width = width;
        canvas.height = height;
        
        let firstParticleInHole = null; 
        let particleIdCounter = 0; 
        let brokenConnections = {}; 
        let cuttingLines = [];
        
        let isStarForming = false; 
        const STAR_FORMING_THRESHOLD = 3; 
        
        const STAR_RADIUS_OUTER = 120; 
        const STAR_RADIUS_INNER = 50; 
        const STAR_POINTS_COUNT = 10; 
        const STAR_MOVE_DISTANCE = 100;
        let starTargetPoints = []; 

        const EJECT_IMMUNITY_DURATION = 2000; 
        const HOLE_COOLDOWN = 3000;
        const CUT_DELAY = 2000;
        const CUTTING_ANIMATION_DURATION = 30;

        function getDistanceToLineSegment(mx, my, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSq = dx * dx + dy * dy;

            if (lengthSq === 0) return Math.sqrt((mx - x1) ** 2 + (my - y1) ** 2);

            let t = ((mx - x1) * dx + (my - y1) * dy) / lengthSq;
            t = Math.max(0, Math.min(1, t));

            const closestX = x1 + t * dx;
            const closestY = y1 + t * dy;

            return Math.sqrt((mx - closestX) ** 2 + (my - closestY) ** 2);
        }
        
        function calculateStarPoints(centerX, centerY) {
            const points = [];
            const rotation = -Math.PI / 2; 
            
            for (let i = 0; i < STAR_POINTS_COUNT; i++) {
                const radius = i % 2 === 0 ? STAR_RADIUS_OUTER : STAR_RADIUS_INNER;
                const angle = (i * Math.PI / (STAR_POINTS_COUNT / 2)) + rotation;
                
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                points.push({ x, y });
            }
            return points;
        }

        let center = { x: width / 2, y: height / 2 };
        const diamondSize = 150; 
        const holeRadius = 15; 
        const lineBreakRadius = 25; 

        let holes = [
            { x: center.x, y: center.y - diamondSize, size: holeRadius, occupied: false, cooldownUntil: 0 }, 
            { x: center.x + diamondSize, y: center.y, size: holeRadius, occupied: false, cooldownUntil: 0 }, 
            { x: center.x, y: center.y + diamondSize, size: holeRadius, occupied: false, cooldownUntil: 0 }, 
            { x: center.x - diamondSize, y: center.y, size: holeRadius, occupied: false, cooldownUntil: 0 } 
        ];
        
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            center = { x: width / 2, y: height / 2 };
            holes = [
                { x: center.x, y: center.y - diamondSize, size: holeRadius, occupied: false, cooldownUntil: 0 },
                { x: center.x + diamondSize, y: center.y, size: holeRadius, occupied: false, cooldownUntil: 0 },
                { x: center.x, y: center.y + diamondSize, size: holeRadius, occupied: false, cooldownUntil: 0 },
                { x: center.x - diamondSize, y: center.y, size: holeRadius, occupied: false, cooldownUntil: 0 }
            ];
            
            initParticles(); 
            starTargetPoints = []; 
        });

        const mouse = { x: null, y: null, radius: 100 }
        window.addEventListener('mousemove', (event) => { mouse.x = event.x; mouse.y = event.y; });
        window.addEventListener('mouseout', () => { mouse.x = null; mouse.y = null; });


        class Particle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 2 + 1;
                this.baseSize = this.size; 
                this.baseVx = Math.random() * 0.5 - 0.25; 
                this.baseVy = Math.random() * 0.5 - 0.25;
                this.vx = this.baseVx; 
                this.vy = this.baseVy;
                this.mass = this.size * this.size;
                this.baseColor = '255, 255, 255'; 
                this.currentColor = this.baseColor; 
                
                this.isInHole = false;
                this.targetHole = -1;
                this.connections = 0; 
                this.isImmune = false; 
                this.ejectTime = 0; 
                this.redFlashFrames = 0; 
                this.id = particleIdCounter++; 
                this.connectionTime = 0; 
                
                this.mouseImmuneUntil = 0; 
            }

            draw() {
                let opacity = 0.8;
                if (Date.now() < this.mouseImmuneUntil && !this.isInHole) {
                    ctx.fillStyle = 'rgba(100, 200, 255, 1)'; 
                } else {
                    ctx.fillStyle = 'rgba(' + this.currentColor + ', ' + opacity + ')';
                }
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.isInHole) {
                }
            }

            ejectForceful(isDisbanding) {
                const currentTime = Date.now();
                
                if (this.targetHole !== -1) {
                    if (!isDisbanding) { 
                        holes[this.targetHole].occupied = false;
                        holes[this.targetHole].cooldownUntil = currentTime + HOLE_COOLDOWN; 
                    }
                }
                
                this.isInHole = false;
                this.targetHole = -1;
                this.connections = 0;
                this.isImmune = false;
                this.ejectTime = currentTime;
                this.mouseImmuneUntil = currentTime + EJECT_IMMUNITY_DURATION;
                
                const maxEjectSpeed = isDisbanding ? 10 : 3; 
                this.vx = (Math.random() - 0.5) * maxEjectSpeed * 2;
                this.vy = (Math.random() - 0.5) * maxEjectSpeed * 2;
                
                this.currentColor = this.baseColor;
                this.size = this.baseSize;
                this.redFlashFrames = 0; 
                this.connectionTime = 0;
                
                for (const key in brokenConnections) {
                    if (key.includes(this.id + '-') || key.includes('-' + this.id)) {
                        delete brokenConnections[key];
                    }
                }
                
                if (this === firstParticleInHole) {
                    firstParticleInHole = null;
                    isStarForming = false;
                }
            }

            eject() {
                this.ejectForceful(false);
            }
            
            checkCollision(otherParticle) {
                if (this.isInHole || otherParticle.isInHole) return;

                const dx = otherParticle.x - this.x;
                const dy = otherParticle.y - this.y;
                const distSq = dx * dx + dy * dy;
                const minDist = this.size + otherParticle.size;
                const minDistSq = minDist * minDist;

                if (distSq < minDistSq && distSq > 0) {
                    const distance = Math.sqrt(distSq);
                    const normalX = dx / distance;
                    const normalY = dy / distance;

                    
                    const overlap = minDist - distance;
                    const adjustment = overlap * 0.5;

                    this.x -= normalX * adjustment;
                    this.y -= normalY * adjustment;
                    otherParticle.x += normalX * adjustment;
                    otherParticle.y += normalY * adjustment;

                    
                    const v1 = this.vx * normalX + this.vy * normalY;
                    const v2 = otherParticle.vx * normalX + otherParticle.vy * normalY;

                    const m1 = this.mass;
                    const m2 = otherParticle.mass;

                    
                    const finalV1 = (v1 * (m1 - m2) + 2 * m2 * v2) / (m1 + m2);
                    const finalV2 = (v2 * (m2 - m1) + 2 * m1 * v1) / (m1 + m2);

                    
                    this.vx += (finalV1 - v1) * normalX;
                    this.vy += (finalV1 - v1) * normalY;
                    otherParticle.vx += (finalV2 - v2) * normalX;
                    otherParticle.vy += (finalV2 - v2) * normalY;
                }
            }


            update() {
                const currentTime = Date.now();

                if (this.isInHole) {
                    const targetX = holes[this.targetHole].x;
                    const targetY = holes[this.targetHole].y; 
                    
                    if (this === firstParticleInHole) {
                    }

                    if (this.connections === 0) {
                        if (this.isImmune) {
                        } else {
                            if (this === firstParticleInHole && isStarForming) {
                                disbandStar(); 
                                return;
                            }

                            this.eject(); 
                            return; 
                        }
                    }
                    
                    this.x += (targetX - this.x) * 0.05;
                    this.y += (targetY - this.y) * 0.05;

                    this.currentColor = '255, 255, 200'; 
                    this.size = this.baseSize * 1.5; 
                    
                    if (this.redFlashFrames > 0) {
                        this.currentColor = '255, 100, 100'; 
                        this.redFlashFrames--;
                    }
                    
                    this.draw();
                    return; 
                }
                
                const isMouseImmune = (currentTime < this.mouseImmuneUntil);

                let dx = this.x - mouse.x;
                let dy = this.y - mouse.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < mouse.radius && !isMouseImmune) { 
                    const proximity = 1 - (distance / mouse.radius);
                    const r = Math.round(255 - 255 * proximity);
                    const g = Math.round(255 - 55 * proximity); 
                    const b = 255;
                    this.currentColor = `${r}, ${g}, ${b}`;

                    const forceDirectionX = dx / distance;
                    const forceDirectionY = dy / distance;
                    const maxSpeed = 10;
                    const pushForce = proximity * maxSpeed;
                    
                    this.vx = forceDirectionX * pushForce * 0.1;
                    this.vy = forceDirectionY * pushForce * 0.1;
                    
                    const cooldownDuration = 2000; 
                    
                    if (currentTime - this.ejectTime >= cooldownDuration) {
                        let minHoleDist = Infinity;
                        let nearestHoleIndex = -1;
                        
                        for (let i = 0; i < holes.length; i++) {
                            if (!holes[i].occupied && currentTime > holes[i].cooldownUntil) {
                                const holeMouseDist = Math.sqrt(
                                    (holes[i].x - mouse.x) ** 2 + (holes[i].y - mouse.y) ** 2
                                );
                                
                                if (holeMouseDist < mouse.radius * 2 && holeMouseDist < minHoleDist) { 
                                    minHoleDist = holeMouseDist;
                                    nearestHoleIndex = i;
                                }
                            }
                        }

                        if (nearestHoleIndex !== -1) {
                            const hole = holes[nearestHoleIndex];
                            const distToHole = Math.sqrt((this.x - hole.x)**2 + (this.y - hole.y)**2);

                            if (distToHole < hole.size * 2) { 
                                this.isInHole = true;
                                this.targetHole = nearestHoleIndex;
                                holes[this.targetHole].occupied = true; 
                                this.vx = 0; 
                                this.vy = 0;
                                this.connections = 0; 
                                this.ejectTime = 0; 
                                this.redFlashFrames = 0; 
                                this.connectionTime = Date.now(); 
                                this.mouseImmuneUntil = 0; 
                                
                                if (firstParticleInHole === null) {
                                    this.isImmune = true; 
                                    firstParticleInHole = this; 
                                } else {
                                    this.isImmune = false;
                                }
                            } else {
                                const pushToHoleX = (hole.x - this.x) / distToHole;
                                const pushToHoleY = (hole.y - this.y) / distToHole;
                                this.vx += pushToHoleX * 0.5;
                                this.vy += pushToHoleY * 0.5;
                            }
                        }
                    } 
                    
                } else {
                    if (isStarForming) {
                        if (starTargetPoints.length > 0) {
                            const targetIndex = this.id % STAR_POINTS_COUNT; 
                            const targetX = starTargetPoints[targetIndex].x;
                            const targetY = starTargetPoints[targetIndex].y;
                            
                            this.vx += (targetX - this.x) * 0.005; 
                            this.vy += (targetY - this.y) * 0.005;
                            
                            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                            const maxSpeed = 3;
                            if (speed > maxSpeed) {
                                this.vx = (this.vx / speed) * maxSpeed;
                                this.vy = (this.vy / speed) * maxSpeed;
                            }
                            this.currentColor = '150, 255, 150';
                            this.size = this.baseSize * 1.2;
                        }
                        
                    } else {
                        if (currentTime < this.mouseImmuneUntil) {
                            this.currentColor = '100, 200, 255'; 
                            this.size = this.baseSize * 1.5;
                        } else {
                            this.vx += (this.baseVx - this.vx) * 0.01; 
                            this.vy += (this.baseVy - this.vy) * 0.01;
                            this.currentColor = this.baseColor;
                            this.size = this.baseSize;
                        }
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;

                if (this.x > width || this.x < 0) this.vx = -this.vx;
                if (this.y > height || this.y < 0) this.vy = -this.vy;

                this.draw();
            }
        }

        function disbandStar() {
            isStarForming = false; 
            starTargetPoints = []; 

            particlesArray.forEach(p => {
                if (p.isInHole) {
                    p.ejectForceful(true); 
                } else {
                    const maxEjectSpeed = 10; 
                    p.vx = (Math.random() - 0.5) * maxEjectSpeed * 2;
                    p.vy = (Math.random() - 0.5) * maxEjectSpeed * 2;
                    p.mouseImmuneUntil = Date.now() + EJECT_IMMUNITY_DURATION; 
                    p.currentColor = '100, 200, 255'; 
                    p.size = p.baseSize * 1.5;
                }
            });
            
            holes.forEach(hole => {
                hole.occupied = false;
                hole.cooldownUntil = Date.now() + HOLE_COOLDOWN; 
            });
            
            firstParticleInHole = null; 
            brokenConnections = {}; 
        }

        
        function findAnchorHole(particlesInHoles) {
            if (particlesInHoles.length !== 4) return -1;
            
            let counts = {};
            particlesInHoles.forEach(p => {
                const c = p.connections;
                counts[c] = (counts[c] || 0) + 1;
            });

            
            const isTargetPattern = counts[3] === 1 && counts[2] === 2 && counts[1] === 1 && Object.keys(counts).length === 3;
            
            if (isTargetPattern) {
                let anchorCandidate = -1;
                let tailCandidate = -1; 
                
                for (const p of particlesInHoles) {
                    if (p.connections === 3) {
                        anchorCandidate = p.targetHole;
                    } else if (p.connections === 1) {
                        tailCandidate = p.targetHole;
                    }
                }
                
                const oppositeIndex = (anchorCandidate + 2) % 4;

                if (tailCandidate === oppositeIndex) {
                    return anchorCandidate;
                }
            }
            
            
            if (Object.keys(counts).length === 1 && counts[3] === 4) {
                if (isStarForming) {
                    disbandStar(); 
                }
                return -1;
            }

            return -1;
        }


        let particlesArray = [];
        const numberOfParticles = 100;

        function initParticles() {
            particlesArray = [];
            holes.forEach(hole => {
                hole.occupied = false;
                hole.cooldownUntil = 0; 
            }); 
            firstParticleInHole = null; 
            particleIdCounter = 0; 
            brokenConnections = {}; 
            isStarForming = false; 
            starTargetPoints = []; 
            cuttingLines = [];
            for (let i = 0; i < numberOfParticles; i++) {
                particlesArray.push(new Particle());
            }
        }
        
        function connect() {
            particlesArray.forEach(p => p.connections = 0); 
            const currentTime = Date.now();

            
            for (let a = 0; a < particlesArray.length; a++) {
                for (let b = a + 1; b < particlesArray.length; b++) {
                    particlesArray[a].checkCollision(particlesArray[b]);
                }
            }


            
            for (let a = 0; a < particlesArray.length; a++) {
                if (particlesArray[a].isInHole) continue; 

                for (let b = a; b < particlesArray.length; b++) {
                    if (particlesArray[b].isInHole) continue;
                    
                    let distance = ((particlesArray[a].x - particlesArray[b].x) ** 2 + (particlesArray[a].y - particlesArray[b].y) ** 2);
                    
                    if (distance < 10000) {
                        let opacityValue = 1 - (distance / 10000);
                        
                        const colorA = particlesArray[a].currentColor.split(', ');
                        const colorB = particlesArray[b].currentColor.split(', '); 
                        
                        const avgR = (parseInt(colorA[0]) + parseInt(colorB[0])) / 2;
                        const avgG = (parseInt(colorA[1]) + parseInt(colorB[1])) / 2;
                        const avgB = (parseInt(colorA[2]) + parseInt(colorB[2])) / 2;

                        ctx.strokeStyle = 'rgba(' + avgR + ', ' + avgG + ', ' + avgB + ',' + opacityValue + ')';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                        ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                        ctx.stroke();
                    }
                }
            }

            
            const particlesInHoles = particlesArray.filter(p => p.isInHole);
            
            if (particlesInHoles.length >= 2) {

                for (let a = 0; a < particlesInHoles.length; a++) {
                    for (let b = a + 1; b < particlesInHoles.length; b++) {
                        
                        let pA = particlesInHoles[a];
                        let pB = particlesInHoles[b];
                        
                        const connectionKey = pA.id < pB.id ? `${pA.id}-${pB.id}` : `${pB.id}-${pA.id}`;
                        
                        if (brokenConnections[connectionKey]) {
                            continue; 
                        }

                        const distToLine = getDistanceToLineSegment(mouse.x, mouse.y, pA.x, pA.y, pB.x, pB.y);
                        
                        let isBroken = false;
                        
                        const pA_Ready = (currentTime - pA.connectionTime) >= CUT_DELAY;
                        const pB_Ready = (currentTime - pB.connectionTime) >= CUT_DELAY;
                        
                        if (mouse.x !== null && distToLine !== null && distToLine < lineBreakRadius && pA_Ready && pB_Ready) {
                            isBroken = true;
                            
                            
                            cuttingLines.push({
                                x1: pA.x, y1: pA.y,
                                x2: pB.x, y2: pB.y,
                                frames: CUTTING_ANIMATION_DURATION,
                                key: connectionKey
                            });
                            
                            pA.redFlashFrames = 5; 
                            pB.redFlashFrames = 5;
                            
                            brokenConnections[connectionKey] = true; 
                            
                        } else {
                            ctx.strokeStyle = 'rgba(255, 255, 200, 0.8)'; 
                        }

                        ctx.lineWidth = 2; 
                        ctx.beginPath();
                        ctx.moveTo(pA.x, pA.y);
                        ctx.lineTo(pB.x, pB.y);
                        ctx.stroke();

                        if (!isBroken) {
                            pA.connections++;
                            pB.connections++;
                            
                            if (pA === firstParticleInHole && pA.isImmune) {
                                pA.isImmune = false;
                            }
                            if (pB === firstParticleInHole && pB.isImmune) {
                                pB.isImmune = false;
                            }
                        }
                    }
                }
                
                const anchorHoleIndex = findAnchorHole(particlesInHoles);

                if (anchorHoleIndex !== -1) {
                    isStarForming = true;
                    if (starTargetPoints.length === 0) {
                        const anchorHole = holes[anchorHoleIndex];
                        let starCenterX = anchorHole.x;
                        let starCenterY = anchorHole.y;
                        
                        
                        switch (anchorHoleIndex) {
                            case 0: 
                                starCenterY -= STAR_MOVE_DISTANCE; 
                                break;
                            case 1: 
                                starCenterX += STAR_MOVE_DISTANCE; 
                                break;
                            case 2: 
                                starCenterY += STAR_MOVE_DISTANCE; 
                                break;
                            case 3: 
                                starCenterX -= STAR_MOVE_DISTANCE; 
                                break;
                        }

                        starTargetPoints = calculateStarPoints(starCenterX, starCenterY);
                    }
                } else {
                    if (isStarForming) {
                        disbandStar(); 
                    }
                }
            }
            
            drawHoles(); 

            
            for (let i = cuttingLines.length - 1; i >= 0; i--) {
                const line = cuttingLines[i];
                const progress = line.frames / CUTTING_ANIMATION_DURATION;
                const opacity = Math.max(0, progress);

                ctx.strokeStyle = `rgba(255, 0, 0, ${opacity})`;
                ctx.lineWidth = 4 * (1 - progress);

                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();

                line.frames--;

                if (line.frames <= 0) {
                    cuttingLines.splice(i, 1);
                }
            }

            
            if (isStarForming && starTargetPoints.length > 0) {
                ctx.strokeStyle = 'rgba(150, 255, 150, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(starTargetPoints[0].x, starTargetPoints[0].y);
                for (let i = 1; i < STAR_POINTS_COUNT; i++) {
                    ctx.lineTo(starTargetPoints[i].x, starTargetPoints[i].y);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }

        function drawHoles() {
            const currentTime = Date.now();
            holes.forEach(hole => {
                let color = 'rgba(100, 100, 100, 0.2)';

                if (hole.occupied) {
                    color = 'rgba(255, 255, 200, 0.5)';
                } else if (currentTime < hole.cooldownUntil) {
                    const remaining = Math.ceil((hole.cooldownUntil - currentTime) / 1000);
                    color = `rgba(50, 50, 50, 0.5)`;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(hole.x, hole.y, hole.size, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
            }
            connect();
        }

        initParticles();
        animate();

    </script>

</body>
</html>